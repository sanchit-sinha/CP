{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "sanchit": {
        "prefix": "sanchit",
        "body": [
            "#include \"bits/stdc++.h\"",
            "using namespace std;",
            "#define f first",
            "#define s second",
            "#define pb push_back",
            "#define ll long long",
            "#define ld long double",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "#define mp make_pair",
            "#define mt make_tuple",
            "#define pll pair<ll, ll>",
            "#define vll vector<ll>",
            "#define vvll vector<vll>",
            "#define vpll vector<pll>",
            "#define all(c) (c).begin(), (c).end()",
            "#define sz(c) (ll)((c).size())",
            "#define get(x, c) get<x>(c)",
            "#define trav(a, x) for (auto a = x.begin(); a != x.end(); a++)",
            "#define rep(i, n) for (ll i = 0; i < (n); i++)",
            "#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)",
            "#define FORR(i, b, a) for (ll i = (b); i >= (a); i--)",
            "",
            "#ifdef LOCAL",
            "bool DBG = 1;",
            "#include \"../debug.cpp\"",
            "#else",
            "bool DBG = 0;",
            "#define debug(...) 42",
            "#define cerr   \\",
            "\tif (false) \\",
            "\tcerr",
            "#endif",
            "",
            "ll power(ll x, ll ex);",
            "inline ll gcd(ll a, ll b);",
            "inline ll max(ll a, ll b);",
            "inline ll min(ll a, ll b);",
            "ll powermod(ll x, ll ex, ll md);",
            "",
            "const ll inf = 4e18 + 9;",
            "const ll mod = 1e9 + 7;",
            "const ld PI = acos(-1);",
            "const ld eps = 1e-9;",
            "",
            "void solve()",
            "{",
            "\t${2:}",
            "}",
            "",
            "int main()",
            "{",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(0);",
            "\tcout.tie(0);",
            "\tcout << fixed << setprecision(20);",
            "",
            "\tll NTC = 1;",
            "\t//${1: cin >> NTC;}",
            "",
            "#ifdef PREPROCESS",
            "\tpreprocess();",
            "#endif",
            "#ifdef SIEVE",
            "\tsieve();",
            "#endif",
            "#ifdef NCR",
            "\tfactorial();",
            "#endif",
            "",
            "\tll PTC = 0;",
            "\twhile ((PTC++) < NTC)",
            "\t{",
            "\t\tcerr << \"Testcase # \" << PTC << \"\\n\";",
            "\t\t// cout << \"Case #\" << PTC << \":\" << ' ';",
            "\t\tsolve();",
            "\t\tcerr << \"*************************\\n\";",
            "\t}",
            "\t// cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";",
            "}",
            "inline ll max(ll a, ll b) { return ((a > b) ? a : b); }",
            "inline ll min(ll a, ll b) { return ((a > b) ? b : a); }",
            "inline ll gcd(ll a, ll b)",
            "{",
            "\tif (b == 0)",
            "\t\treturn a;",
            "\ta %= b;",
            "\treturn gcd(b, a);",
            "}",
            "ll power(ll x, ll y)",
            "{",
            "\tif (y == 0)",
            "\t\treturn 1;",
            "\tll a = power(x, y / 2);",
            "\tif (y % 2 == 0)",
            "\t\treturn a * a;",
            "\telse",
            "\t\treturn x * a * a;",
            "}",
            "ll powermod(ll x, ll ex, ll md)",
            "{",
            "\tll ans = 1ll;",
            "\twhile (ex > 0)",
            "\t{",
            "\t\tif (ex & 1ll)",
            "\t\t\tans = (ans * x) % md;",
            "\t\tex >>= 1ll;",
            "\t\tx = (x * x) % md;",
            "\t}",
            "\treturn ans;",
            "}",
            ""
        ],
        "description": "template for CP "
    },
    "BFS_singlesource": {
        "prefix": "BFS_singlesource",
        "body": [
            "bool vis[N];",
            "void bfs(ll node)",
            "{",
            "\tqueue<ll> q;",
            "\tvis[node] = 1;",
            "\tq.push(node);",
            "\twhile (!q.empty())",
            "\t{",
            "\t\tll cur = q.front();",
            "\t\tq.pop();",
            "\t\tfor (auto child : v[cur])",
            "\t\t{",
            "\t\t\tif (!vis[child])",
            "\t\t\t{",
            "\t\t\t\tvis[child] = 1;",
            "\t\t\t\tq.push(child);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "BFS for one source"
    },
    "EulerTotientFunction": {
        "prefix": "EulerTotientFunction",
        "body": [
            "// counts the number of integers between 1 and x inclusive, which are coprime to x",
            "ll phi(ll x)",
            "{",
            "\tll ans = x;",
            "\tfor (ll i = 2; i * i <= x; i++)",
            "\t{",
            "\t\tif (x % i == 0)",
            "\t\t{",
            "\t\t\twhile (x % i == 0)",
            "\t\t\t\tx /= i;",
            "\t\t\tans -= ans / i;",
            "\t\t}",
            "\t}",
            "\tif (x > 1)",
            "\t\tans -= ans / x;",
            "\treturn ans;",
            "}"
        ],
        "description": "finds number of numbers less than x and co-prime to x "
    },
    "Finding_cycles_in_undirected_graph": {
        "prefix": "Finding_cycles_in_undirected_graph",
        "body": [
            "vll v[N];",
            "ll cycle_start, cycle_end;",
            "ll colour[N], parent[N];",
            "vll cycle;",
            "bool dfs(ll node, ll par)",
            "{",
            "\tcolour[node] = 1;",
            "\tfor (auto child : v[node])",
            "\t{",
            "\t\tif (child == par)",
            "\t\t\tcontinue;",
            "\t\telse",
            "\t\t{",
            "\t\t\tif (colour[child] == 0)",
            "\t\t\t{",
            "\t\t\t\tparent[child] = node;",
            "\t\t\t\tif (dfs(child, parent[child]))",
            "\t\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t\telse if (colour[child] == 1)",
            "\t\t\t{",
            "\t\t\t\tcycle_end = node;",
            "\t\t\t\tcycle_start = child;",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tcolour[node] = 2;",
            "\treturn false;",
            "}",
            "bool find_cycle()",
            "{",
            "\tmemset(parent, -1, sizeof(parent));",
            "\tmemset(colour, 0, sizeof(colour));",
            "\tcycle_start = -1;",
            "\t// n : number of vertices ( 1 - indexed)",
            "\tfor (ll i = 1; i <= n; i++)",
            "\t{",
            "\t\tif (colour[i] == 0)",
            "\t\t{",
            "\t\t\tif (dfs(i, parent[i]))",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\t}",
            "",
            "\tif (cycle_start == -1)",
            "\t{",
            "\t\t// not found any cycle",
            "\t\treturn false;",
            "\t}",
            "\telse",
            "\t{",
            "\t\t// found cycle",
            "\t\tcycle.pb(cycle_start);",
            "\t\tfor (ll i = cycle_end; i != cycle_start; i = parent[i])",
            "\t\t{",
            "\t\t\tcycle.pb(i);",
            "\t\t}",
            "\t\tcycle.pb(cycle_start);",
            "\t\treverse(all(cycle));",
            "",
            "\t\treturn true;",
            "\t}",
            "}"
        ],
        "description": "finding cycles in undirected graph"
    },
    "ncr": {
        "prefix": "ncr",
        "body": [
            "#define NCR",
            "const ll mX = ${1:N};",
            "ll fact[mX + 11] , invfact[mX + 11];",
            "void factorial(){",
            "\tfact[0] = invfact[0] = 1;",
            "\tfor(ll i = 1 ; i < mX ; i++){",
            "\t\tfact[i] = i * fact[i - 1];",
            "\t\tfact[i] %= mod;",
            "\t}",
            "\tinvfact[mX - 1] = powermod(fact[mX - 1] , mod - 2 , mod); // if mod is prime",
            "\tfor(ll i = mX - 2 ; i > 0 ; i--){",
            "\t\tinvfact[i] = invfact[i + 1] * (i + 1);",
            "\t\tinvfact[i] %= mod;",
            "\t}",
            "}",
            "ll ncr(ll n , ll r){",
            "\tif(r > n || n < 0 || r < 0)return 0;",
            "\tll p = (fact[n] * invfact[r]) % mod;",
            "\tp *= invfact[n - r];",
            "\treturn p%mod;",
            "}"
        ],
        "description": "finding factorial and combinations for large numbers"
    },
    "kmp": {
        "prefix": "kmp",
        "body": [
            "// 1 indexed .. p[i] is the length of the longest proper prefix of the substring s[0 … i - 1] which is also a suffix of this substring ",
            "vector<ll> LPS(string &s){",
            "\tint n = (int)s.length();",
            "\tvector<ll> p(n + 1);",
            "\tp[0] = 0; p[1] = 0;",
            "\tint j;",
            "\tfor(int i = 2 ; i <= n ; i++){",
            "\t   j = p[i - 1];",
            "\t   while(j > 0 && s[j] != s[i - 1]) j = p[j]; // p[p[j]] gives second largest prefix of the substring s[0 … i - 1]",
            "\t   if(s[j] == s[i-1]) j++;",
            "\t   p[i] = j;",
            "\t}",
            "\treturn p;",
            "}",
            ""
        ],
        "description": "kmp function"
    },
    "lca_class": {
        "prefix": "lca_class",
        "body": [
            "class lca{",
            "\tpublic:",
            "\tll MAX_D;",
            "\tll dfs_timer;",
            "\tvector<vector<ll>> g;",
            "\tvector<vector<ll>> ancestor;",
            "\tvector<bool> visited;",
            "\tvector<ll> depth;",
            "\tvector<ll> en;",
            "\tvector<ll> ex;",
            "\tvector<ll> par;",
            "\tlca(ll n){",
            "\t\tg.resize(n + 1);",
            "\t\tvisited.resize(n + 1 , 0);",
            "\t\tdepth.resize(n + 1 , 0);",
            "\t\ten.resize(n + 1, 0);",
            "\t\tex.resize(n + 1, 0);",
            "\t\tpar.resize(n + 1, -1);",
            "\t\tdfs_timer = 0;",
            "\t\tMAX_D = ceil(log2(n));",
            "\t\tancestor = vector<vector<ll>>(MAX_D + 1, vector<ll>(n + 1 , -1));",
            "\t}",
            "\tvoid addEdge(ll l, ll r){",
            "\t\tg[l].push_back(r);",
            "\t}",
            "\tvoid do_dfs(ll sr){",
            "\t\tvisited[sr] = true;",
            "\t\tdfs_timer++;",
            "\t\ten[sr] = dfs_timer;",
            "\t\tfor(auto child : g[sr]){",
            "\t\t\tif(!visited[child]){",
            "\t\t\t\tancestor[0][child] = sr;",
            "\t\t\t\tdepth[child] = depth[sr] + 1;",
            "\t\t\t\tpar[child] = sr; ",
            "\t\t\t\tdo_dfs(child);",
            "\t\t\t}",
            "\t\t}",
            "\t\tdfs_timer++;",
            "\t\tex[sr] = dfs_timer;",
            "\t}",
            "\tvoid build_lca_table(){",
            "\t\tll n = (ll) g.size() - 1;",
            "\t\tthis->do_dfs(1);",
            "\t\tfor(ll d = 1; d <= MAX_D; d++){",
            "\t\t\tfor(ll i = 1; i <= n; i++){",
            "\t\t\t\tif(ancestor[d - 1][i] != -1){",
            "\t\t\t\t\tancestor[d][i] = ancestor[d - 1][ancestor[d - 1][i]];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tll climb(ll l , ll d){",
            "\t\tll i = l;",
            "\t\tfor(ll dd = 0; (dd <= MAX_D && i != -1) ;dd++){",
            "\t\t\tif((1 << dd) & d) i = ancestor[dd][i];",
            "\t\t}",
            "\t\treturn i;",
            "\t}",
            "\tll get_lca(ll i , ll j){",
            "\t\tif(depth[i] > depth[j]) i = climb(i , depth[i] - depth[j]);",
            "\t\tif(depth[j] > depth[i]) j = climb(j , depth[j] - depth[i]);",
            "\t\tassert(depth[j] == depth[i]);",
            "\t\tif(i == j) return i;",
            "\t\tfor(ll d = MAX_D; d >= 0; --d){",
            "\t\t\tif(ancestor[d][i] != ancestor[d][j]){",
            "\t\t\t\ti = ancestor[d][i];",
            "\t\t\t\tj = ancestor[d][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ancestor[0][i];",
            "\t}",
            "\tll isAncestor(ll u , ll v){",
            "\t\treturn (en[u] <= en[v] && ex[v] <= ex[u]);",
            "\t}",
            "};"
        ],
        "description": "class for LCA"
    },
    "LPS": {
        "prefix": "LPS",
        "body": [
            "// 1 indexed .. p[i] is the length of the longest proper prefix of the substring s[0 … i - 1] which is also a suffix of this substring ",
            "vector<ll> LPS(string &s){",
            "\tint n = (int)s.length();",
            "\tvector<ll> p(n + 1);",
            "\tp[0] = 0; p[1] = 0;",
            "\tint j;",
            "\tfor(int i = 2 ; i <= n ; i++){",
            "\t   j = p[i - 1];",
            "\t   while(j > 0 && s[j] != s[i - 1]) j = p[j]; // p[p[j]] gives second largest prefix of the substring s[0 … i - 1]",
            "\t   if(s[j] == s[i-1]) j++;",
            "\t   p[i] = j;",
            "\t}",
            "\treturn p;",
            "}"
        ],
        "description": "finding longest prefix which is also the suffix"
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "ll tree[4*N],a[N];",
            "ll pull(ll l,ll r){",
            "\tll p = min(l,r); //operation",
            "\treturn p;\t\t\t",
            "}",
            "void build(ll node,ll l,ll r){",
            "\tif(l==r) tree[node]=a[l];",
            "\telse{",
            "\t\tll mid=l+(r-l)/2;",
            "\t\tbuild(2*node,l,mid);",
            "\t\tbuild(2*node+1,mid+1,r);",
            "\t\t",
            "\t\ttree[node] = pull(tree[node*2],tree[node*2+1]);",
            "\t}",
            "}",
            "void update(ll node,ll l,ll r,ll index,ll val){",
            "\tif(index>r || index<l) return ;",
            "\tif(l==r) a[index]=val , tree[node]=val; //update operation",
            "\telse{",
            "\t\tll mid=l+(r-l)/2;",
            "\t\tupdate(node*2,l,mid,index,val);",
            "\t\tupdate(node*2+1,mid+1,r,index,val);",
            "\t\t",
            "\t\ttree[node] = pull(tree[node*2],tree[node*2+1]);",
            "\t}",
            "}",
            "ll query(ll node,ll l,ll r,ll start,ll end){",
            "\tif(end<l || start>r) return LLONG_MAX; //operation (inf , -inf , 0 ...)",
            "\telse if(start<=l && end>=r) return tree[node];",
            "\telse{",
            "\t\tll mid=l+(r-l)/2;",
            "\t\tll p1=query(2*node,l,mid,start,end);",
            "\t\tll p2=query(2*node+1,mid+1,r,start,end);",
            "\t\t",
            "\t\treturn pull(p1,p2); //operation",
            "\t}",
            "}",
            "//build(1,0,n-1) .... query(1,0,n-1,l,r) .... update(1,0,n-1,x,a[x])"
        ],
        "description": "function for min - segment tree"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "#define SIEVE",
            "const ll mX = ${1:N};",
            "bool prime[mX + 11]; ",
            "void sieve(){ ",
            "\tmemset(prime,true,sizeof(prime)); ",
            "\tfor (ll p = 2 ; p*p <= mX ; p++){ ",
            "\t\tif (prime[p]==true) { ",
            "\t\t\tfor (ll i = p*p ; i <= mX; i += p) prime[i]=false; ",
            "\t\t} ",
            "\t} ",
            "}",
            "// note that the complexity is sqrt(n)*log(n)",
            "// can't store all prime numbers directly(need to iterate all numbers : nlog(n)) "
        ],
        "description": "finding primes less than n in nlogn"
    },
    "trie": {
        "prefix": "trie",
        "body": [
            "const int ALPHABET_SIZE = 26; ",
            "// trie node ",
            "struct TrieNode{ ",
            "\t\tstruct TrieNode* children[ALPHABET_SIZE]; ",
            "\t\t// isEndOfWord is true if the node represents ",
            "\t\t// end of a word ",
            "\t\tbool isEndOfWord; ",
            "}; ",
            "// struct TrieNode* root = getNode()",
            "",
            "// Returns new trie node (initialized to NULLs) ",
            "struct TrieNode* getNode(void){ ",
            "\t\tstruct TrieNode* pNode = new TrieNode; ",
            "\t\tpNode->isEndOfWord = false; ",
            "\t\tfor (int i = 0; i < ALPHABET_SIZE; i++) ",
            "\t\t\t\tpNode->children[i] = NULL; ",
            "\t\treturn pNode; ",
            "} ",
            "//struct TrieNode* root = getNode(); ",
            "  ",
            "// If not present, inserts key into trie ",
            "// If the key is prefix of trie node, just ",
            "// marks leaf node ",
            "void insert(struct TrieNode* root, string key){ ",
            "\t\tstruct TrieNode* pCrawl = root; ",
            "\t\tfor (int i=0; i<(int)key.size(); i++) { ",
            "\t\t\t\tint index = key[i] - 'a'; ",
            "\t\t\t\tif (!pCrawl->children[index]) pCrawl->children[index] = getNode(); ",
            "\t\t\t\tpCrawl = pCrawl->children[index]; ",
            "\t\t} ",
            "\t\t// mark last node as leaf ",
            "\t\tpCrawl->isEndOfWord = true; ",
            "} ",
            "// insert(root, keys); ",
            "",
            "// Returns true if key presents in trie, else ",
            "// false ",
            "bool search(struct TrieNode* root, string key) { ",
            "\t\tstruct TrieNode* pCrawl = root; ",
            "\t\tfor (int i=0; i<(int)key.size(); i++) { ",
            "\t\t\t\tint index=(key[i]-'a'); ",
            "\t\t\t\tif (!pCrawl->children[index]) return false; ",
            "\t\t\t\tpCrawl = pCrawl->children[index]; ",
            "\t\t} ",
            "\treturn (pCrawl != NULL && pCrawl->isEndOfWord); ",
            "} ",
            "// search(root, key)",
            "",
            "// Returns true if root has no children, else false ",
            "bool isEmpty(TrieNode* root) { ",
            "\t\tfor (int i=0; i<ALPHABET_SIZE; i++) if (root->children[i]) return false; ",
            "\t\treturn true; ",
            "} ",
            "  ",
            "// Recursive function to delete a key from given Trie ",
            "TrieNode* remove(TrieNode* root, string key, int depth = 0){ ",
            "\t\t// If tree is empty ",
            "\t\tif (!root) return NULL; ",
            "\t\t// If last character of key is being processed ",
            "\t\tif (depth==(int)key.size()){ ",
            "\t\t\t\t// This node is no more end of word after ",
            "\t\t\t\t// removal of given key ",
            "\t\t\t\tif (root->isEndOfWord) root->isEndOfWord = false; ",
            "\t\t",
            "\t\t\t\t// If given is not prefix of any other word ",
            "\t\t\t\tif (isEmpty(root)) { ",
            "\t\t\t\t\t\tdelete (root); ",
            "\t\t\t\t\t\troot = NULL; ",
            "\t\t\t\t} ",
            "\t\t\t\treturn root; ",
            "\t\t} ",
            "\t\t",
            "\t\t// If not last character, recur for the child ",
            "\t\t// obtained using ASCII value ",
            "\t\tint index = key[depth] - 'a'; ",
            "\t\troot->children[index] = remove(root->children[index], key, depth + 1); ",
            "\t\t",
            "\t\t// If root does not have any child (its only child got  ",
            "\t\t// deleted), and it is not end of another word. ",
            "\t\tif (isEmpty(root) && root->isEndOfWord == false) { ",
            "\t\t\t\tdelete (root); ",
            "\t\t\t\troot = NULL; ",
            "\t\t} ",
            "\t\t",
            "\t\treturn root; ",
            "} ",
            "// remove(root, key)",
            ""
        ],
        "description": "code for trie"
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "ll dis[N] , parent[N];",
            "vll cycle;",
            "// finding (shortest path from a source + negative cycle reachable from source) in a directed graph ~O(nm)",
            "void bellman_ford(ll node){",
            "\tFOR(i , 1 , n) dis[i] = inf;",
            "",
            "\tdis[node] = 0;",
            "\tll cycle_node = -1;",
            "\tFOR(i , 1 , n){",
            "\t\tcycle_node = -1;",
            "\t\tFOR(j , 1 , n){",
            "\t\t\tll from = j;",
            "\t\t\tfor(auto child : v[from]){",
            "\t\t\t\tll to = child.f;",
            "\t\t\t\tll len = child.s;",
            "",
            "\t\t\t\tif(dis[from] < inf){",
            "\t\t\t\t\tif(dis[from] + len < dis[to]){",
            "\t\t\t\t\t\tdis[to] = max(-inf , dis[from] + len);",
            "\t\t\t\t\t\tparent[to] = from;",
            "\t\t\t\t\t\tcycle_node = to;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tif(cycle_node != -1){",
            "\t\trep(i , n) cycle_node = parent[cycle_node];",
            "\t\tfor(ll i = cycle_node ; ; i = parent[i]){",
            "\t\t\tcycle.pb(i);",
            "\t\t\tif(i == cycle_node && sz(cycle) > 1) break;",
            "\t\t}",
            "\t\treverse(all(cycle));",
            "\t}",
            "}"
        ],
        "description": "Bellman ford algorithm"
    },
    "dfs_without_parent": {
        "prefix": "dfs_without_parent",
        "body": [
            "vector<ll> v[N];",
            "bool vis[N];",
            "void dfs(ll node){",
            "\tvis[node]=1;",
            "\tfor(auto child : v[node]){",
            "\t\tif(!vis[child]){",
            "\t\t\tdfs(child);",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Dfs traversal without parent parameter"
    },
    "dfs_with_parent": {
        "prefix": "dfs_with_parent",
        "body": [
            "ll prnt[N];",
            "vector<ll> v[N];",
            "void dfs (ll node , ll parent){",
            "\tprnt[node] = parent;",
            " ",
            "\tfor(auto child:v[node]){",
            "\tif(child!=parent){",
            "\t\t\tdfs(child,node);",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Dfs traversal using parent argument"
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "bool vis[N];",
            "void dij(ll node){",
            "\tset<pll> s;",
            "\tFOR(i, 1, n){",
            "\t\tif(i == node) continue;",
            "\t\telse{",
            "\t\t\tdis[i] = LLONG_MAX;",
            "\t\t\ts.insert(mp(dis[i], i));",
            "\t\t}",
            "\t}",
            "\ts.insert(mp(dis[node], node));",
            "\twhile(!s.empty()){",
            "\t\tll from = s.begin()->second;",
            "\t\tvis[from] = 1;",
            "\t\ts.erase(s.begin());",
            "\t\tfor(auto child : v[from]){",
            "\t\t\tll to = child.first;",
            "\t\t\tll len = child.second;",
            "\t\t\tif(!vis[to]){",
            "\t\t\t\tif(dis[from] + len < dis[to]){",
            "\t\t\t\t\ts.erase(s.find(mp(dis[to], to)));",
            "\t\t\t\t\tdis[to] = dis[from] + len;",
            "\t\t\t\t\ts.insert(mp(dis[to], to));",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "} "
        ],
        "description": "Dijkstra algotihm"
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "struct FenwickTree {",
            "\tvector<long long> bit;  // binary 1-indexed tree",
            "\tint n;",
            "",
            "\tFenwickTree(int n) {",
            "\t\tthis->n = n;",
            "\t\tbit.assign(n + 1, 0ll) ;",
            "\t}",
            "",
            "\tFenwickTree(vector<long long> a) : FenwickTree(a.size()) { // a : 1 - indexed",
            "\t\tfor (size_t i = 1; i < a.size(); i++)",
            "\t\t\tupdate(i, a[i]);",
            "\t}",
            "",
            "\tvoid update(int x , ll increment) {",
            "\t\twhile (x <= n) {",
            "\t\t\tbit[x] += increment; // update operation",
            "\t\t\tx += (x & -x);",
            "\t\t}",
            "\t}",
            "",
            "\tll query(int x) { // 1 .. x",
            "\t\tll val = 0ll; // operation (inf , -inf , 0 ...)",
            "\t\twhile (x > 0) {",
            "\t\t\tval += bit[x]; // operation",
            "\t\t\tx -= (x & -x);",
            "\t\t}",
            "\t\treturn val;",
            "\t}",
            "",
            "\tll query(int l, int r) { // l .. r",
            "\t\treturn query(r) - query(l - 1);",
            "\t}",
            "};",
            ""
        ],
        "description": "class for fenwick tree"
    },
    "bridges_in_undirected_graph": {
        "prefix": "bridges_in_undirected_graph",
        "body": [
            "/* finding number of bridges in an undirected graph */",
            "vll v[N];",
            "ll level[N], dp[N]; // dp[i] : no of back edges passing the edge between i and parent[i]",
            "void dfs(int node, int pr) {",
            "\tfor (auto child : v[node]) {",
            "\t\tif (level[child] == 0) {",
            "\t\t\tlevel[child] = level[node] + 1;",
            "\t\t\tdfs(child, node);",
            "\t\t\tdp[node] += dp[child];",
            "\t\t}",
            "\t\telse if (level[child] < level[node]) dp[node]++;",
            "\t\telse if (level[child] > level[node]) dp[node]--;",
            "\t}",
            "\tdp[node]--;",
            "}",
            "ll findBridges() {",
            "\tlevel[1] = 1;",
            "\tdfs(1, -1);",
            "",
            "\tll ans = 0ll;",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tif (dp[i] == 0 && level[i] > 1) {",
            "\t\t\t/*i -> parent[i]: this edge is a bridge */",
            "\t\t\tans++;",
            "\t\t}",
            "\t}",
            "",
            "\treturn ans;",
            "}",
            ""
        ],
        "description": "finding bridges in undirected graph"
    },
    "permutation": {
        "prefix": "permutation",
        "body": [
            "void find_permutation(vll &permutation, set<ll> &str, ll n, ll k, const vll &fact) { // k : 1 indexed",
            "\tif (k == 0) {",
            "\t\tfor (auto it = str.rbegin(); it != str.rend(); it++) {",
            "\t\t\tpermutation.pb(*it);",
            "\t\t}",
            "\t\tstr.clear();",
            "\t\treturn;",
            "\t}",
            "",
            "\tll moves_placing_smallest = fact[n - 1]; // update",
            "\t// place beta'th position if, beta * moves_placing_smallest >= k (considering all unique)",
            "\tll first_place = (k + moves_placing_smallest - 1) / moves_placing_smallest;  // first place : 1 indexed",
            "",
            "\tll element = -1;",
            "\tll pos = 1;",
            "\tfor (auto x : str) { // finding element at first place : update",
            "\t\tif (pos == first_place) {",
            "\t\t\telement = x;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tpos++;",
            "\t}",
            "",
            "\tif (element != -1) {",
            "\t\tpermutation.pb(element);",
            "\t\tk -= (first_place - 1) * moves_placing_smallest; // update k if first_place > 1",
            "\t\tif (str.count(element)) str.erase(str.find(element));",
            "\t\tfind_permutation(permutation, str, n - 1, k, fact);",
            "\t}",
            "\treturn ;",
            "}",
            ""
        ],
        "description": "find permutation of list"
    },
    "find_prime_factor": {
        "prefix": "find_prime_factor",
        "body": [
            "// finding prime factors in sqrt logn",
            "vector<ll> prime;",
            "ll temp=x;",
            "for(ll i=2;i<=sqrt(x);i++){",
            "\tif(temp%i==0){",
            "\t\twhile(temp%i==0) temp/=i;",
            "\t\tprime.pb(i);",
            "",
            "\t}",
            "}",
            "if(temp!=1) prime.pb(temp);",
            ""
        ],
        "description": "finding prime factors in sqrtn"
    },
    "dsu": {
        "prefix": "dsu",
        "body": [
            "ll sz[N];",
            "ll parent[N];",
            "void make_set(ll node){",
            "\tparent[node] = node;",
            "\tsz[node] = 1;",
            "}",
            "ll find_set(ll a){",
            "\tif(a == parent[a]) return a;",
            "\treturn parent[a] = find_set(parent[a]);",
            "}",
            "void union_set(ll a , ll b){",
            "\tll p1 = find_set(a);",
            "\tll p2 = find_set(b);",
            "\tif(p1 != p2){",
            "\t\tif(sz[p2] > sz[p1]) swap(p1 , p2);",
            "\t\tparent[p2] = p1;",
            "\t\tsz[p1] += sz[p2];",
            "\t}",
            "}",
            "",
            ""
        ],
        "description": "code for dsu"
    },
    "dx": {
        "prefix": "dx",
        "body": [
            "ll dx[4]={1,-1,0,0};",
            ""
        ]
    },
    "dy": {
        "prefix": "dy",
        "body": [
            "ll dy[4]={0,0,1,-1};",
            ""
        ]
    },
    "eulerian_path_in_directed _graph": {
        "prefix": "eulerian_path_in_directed _graph",
        "body": [
            "vll v[N];",
            "vll EulerPath;",
            "ll in[N], out[N];",
            "void dfs_EulerPath(ll node) {",
            "\twhile (out[node]) {",
            "\t\tdfs_EulerPath(v[node][--out[node]]);",
            "\t}",
            "\tEulerPath.push_back(node);",
            "}",
            "bool findEulerianPath() { /* 1: if its possible to find a eulerPath */",
            "\t// calculate the in and out degree for each node",
            "\tfor (int i = 1; i <= n; i++)",
            "\t\tfor (int j = 0; j < (int)v[i].size(); j++)",
            "\t\t\tin[v[i][j]]++, out[i]++;",
            "",
            "\t// check if its possible to find euler path or not",
            "\tbool ok = 1;",
            "\tll numStartNode = 0, numEndNode = 0;",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tif (out[i] - in[i] > 1 || in[i] - out[i] > 1) ok = 0;",
            "\t\telse if (out[i] - in[i] == 1) numStartNode++;",
            "\t\telse if (in[i] - out[i] == 1) numEndNode++;",
            "\t}",
            "\tif (ok) ok = ((numEndNode == 0 && numStartNode == 0) || (numEndNode == 1 && numStartNode == 1));",
            "\tif (!ok) return false;",
            "",
            "\tll node = 1;",
            "\tfor (int i = 1; i <= n; i++)",
            "\t\tif (out[i] - in[i] == 1)",
            "\t\t\tnode = i;",
            "",
            "\tdfs_EulerPath(node);",
            "",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tif (out[i]) return 0;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            ""
        ],
        "description": "finding eulerian path in directed graph"
    },
    "eulerian_path_in_undirected_graph": {
        "prefix": "eulerian_path_in_undirected_graph",
        "body": [
            "set<int> v[N];",
            "vector<int> EulerPath;",
            "int out[N];",
            "void dfs_EulerPath(int node) {",
            "\twhile (out[node]) {",
            "\t\tint child = *v[node].begin();",
            "\t\tv[node].erase(v[node].find(child));",
            "\t\tv[child].erase(v[child].find(node));",
            "",
            "\t\tout[node]--;",
            "\t\tout[child]--;",
            "",
            "\t\tdfs_EulerPath(child);",
            "\t}",
            "\tif (!out[node]) EulerPath.push_back(node);",
            "}",
            "",
            "bool findEulerianPath() { /* 1: if its possible to find a eulerPath */",
            "\t// calculate the degree for each node",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tdebug(i, v[i]);",
            "\t\ttrav(it, v[i]) {",
            "\t\t\tout[i]++;",
            "\t\t}",
            "\t}",
            "",
            "\t// check if its possible to find euler path or not",
            "\tint node = -1;",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tif (out[i] & 1) return 0;",
            "\t\telse node = i;",
            "\t}",
            "\tif (node == -1) return 0;",
            "",
            "\tdfs_EulerPath(node);",
            "",
            "\t// checking if all the edges are connected or not",
            "\tfor (int i = 1; i <= n; i++) {",
            "\t\tif (out[i]) return 0;",
            "\t}",
            "",
            "\treturn true;",
            "}",
            ""
        ],
        "description": "finding eulerian path in undirected graph"
    },
    "floyd_warshall": {
        "prefix": "floyd_warshall",
        "body": [
            "ll a[N][N], dp[N][N];",
            "// shortest path b/w pair of nodes in directed/undirected graph with any weights in O(n^3)",
            "void Floyd_Warshall(){",
            "\tFOR(k , 1 , n){",
            "\t\tFOR(i , 1 , n){",
            "\t\t\tFOR(j , 1 , n){",
            "\t\t\t\tif(dp[i][k] < inf && dp[k][j] < inf){",
            "\t\t\t\t\tdp[i][j] = min(dp[i][j] , dp[i][k] + dp[k][j]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// finding pairs having negative cycle",
            "\tFOR(k , 1 , n){",
            "\t\tFOR(i , 1 , n){",
            "\t\t\tFOR(j , 1 , n){",
            "\t\t\t\tif(dp[k][j] < inf &&  dp[j][j] < 0 && dp[j][i] < inf){",
            "\t\t\t\t\tdp[i][j] = -inf;",
            "\t\t\t\t}\t\t\t\t",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            ""
        ],
        "description": "floyd warshall algorithm"
    },
    "generator_template": {
        "prefix": "generator_template",
        "body": [
            "#include \"bits/stdc++.h\"",
            "using namespace std;",
            "#define IOS {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}",
            "#define pb push_back",
            "#define ll long long",
            "#define ld long double",
            "#define all(c) (c).begin(),(c).end()",
            "#define sz(c) (int)(c.size())",
            "#define mp make_pair",
            "#define mt make_tuple",
            "#define get(x,c) get<x>(c)",
            "#define trav(a,x) for(auto a=x.begin();a!=x.end();a++)",
            "#define rep(i,n) for(int i=0;i<n;i++)",
            "#define FOR(i,a,b) for(int i=a;i<=b;i++)",
            "#define FORR(i,b,a) for(int i=b;i>=a;i--)",
            "#define lb lower_bound",
            "#define ub upper_bound",
            "#define pll pair<ll,ll>",
            "#define vll vector<ll>",
            "#define vpll vector<pll>",
            "#define f first",
            "#define s second",
            "",
            "inline ll gcd(ll a,ll b) {if(b==0)return a;a%=b;return gcd(b,a);}",
            "inline ll max(ll a,ll b) {return((a>b)?a:b);}",
            "inline ll min(ll a,ll b) {return((a>b)?b:a);}",
            "ll power(ll x,ll ex);",
            "ll powermod(ll x,ll ex,ll md);",
            "",
            "const ll inf = 1e18 + 9;",
            "const ll mod = 1e9 + 7;",
            "const ld PI = acos(-1);",
            "const ld eps = 1e-9;",
            "",
            "const ll N = 1e5+11;",
            "",
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "ll range(ll l ,ll r){",
            "\tll n = uniform_int_distribution<int> (l , r)(rng);",
            "\treturn n;",
            "}",
            "",
            "int main(int argc, char* argv[]) {",
            "\tll n = range($1,$2);",
            "\tcout << n <<\"\\n\";",
            "\t$4",
            "}\t\t",
            ""
        ],
        "description": "template for generating testcases"
    },
    "generic_queue": {
        "prefix": "generic_queue",
        "body": [
            "// insert from front, remove from front, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fstack{ // like min stack ",
            "\tstack<T> stk , fstk;",
            "\tF func;",
            "",
            "\tfstack(const F &f): func(f) {};",
            "",
            "\tfstack(){",
            "\t\tfstack(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tif(stk.empty()) fstk.push(add);",
            "\t\telse fstk.push(func(fstk.top() , add));",
            "",
            "\t\tstk.push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tassert(!stk.empty());",
            "\t\tstk.pop();",
            "\t\tfstk.pop();",
            "\t}",
            "",
            "\tT top(){",
            "\t\tassert(!stk.empty());",
            "\t\treturn stk.top();",
            "\t}",
            "",
            "\tT query(){",
            "\t\tassert(!fstk.empty());",
            "\t\treturn fstk.top();",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn stk.empty();",
            "\t}",
            "};",
            "",
            "// insert from front, remove from back, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fqueue{ // like min queue ",
            "\tfstack<T> stk[2];",
            "\tF func;",
            "",
            "\tfqueue(const F &f) : func(f){",
            "\t\tstk[0] = fstack<T> (f);",
            "\t\tstk[1] = fstack<T> (f);",
            "\t}",
            "",
            "\tfqueue(){",
            "\t\tfqueue(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tstk[0].push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tif(!stk[1].empty()) stk[1].pop();",
            "\t\telse{",
            "\t\t\twhile(!stk[0].empty()){",
            "\t\t\t\tstk[1].push(stk[0].top());",
            "\t\t\t\tstk[0].pop();",
            "\t\t\t}",
            "",
            "\t\t\tstk[1].pop();",
            "\t\t}",
            "\t}",
            "",
            "\tT query(){",
            "\t\tif(stk[1].empty()) return stk[0].query();",
            "\t\telse if(stk[0].empty()) return stk[1].query();",
            "\t\telse return func(stk[0].query() , stk[1].query());",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn (stk[0].empty() && stk[1].empty());",
            "\t}",
            "};",
            "// Usage :: fqueue<ll> gcdq([&](ll x , ll y){return gcd(x , y);});",
            "/* any function that can be used with seg trees can be used here : min , max , gcd , xor */",
            ""
        ],
        "description": "generic queue implementation like min-max-queue"
    },
    "generic_stack": {
        "prefix": "generic_stack",
        "body": [
            "// insert from front, remove from front, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fstack{ // like min stack ",
            "\tstack<T> stk , fstk;",
            "\tF func;",
            "",
            "\tfstack(const F &f): func(f) {};",
            "",
            "\tfstack(){",
            "\t\tfstack(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tif(stk.empty()) fstk.push(add);",
            "\t\telse fstk.push(func(fstk.top() , add));",
            "",
            "\t\tstk.push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tassert(!stk.empty());",
            "\t\tstk.pop();",
            "\t\tfstk.pop();",
            "\t}",
            "",
            "\tT top(){",
            "\t\tassert(!stk.empty());",
            "\t\treturn stk.top();",
            "\t}",
            "",
            "\tT query(){",
            "\t\tassert(!fstk.empty());",
            "\t\treturn fstk.top();",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn stk.empty();",
            "\t}",
            "};",
            "",
            "// insert from front, remove from back, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fqueue{ // like min queue ",
            "\tfstack<T> stk[2];",
            "\tF func;",
            "",
            "\tfqueue(const F &f) : func(f){",
            "\t\tstk[0] = fstack<T> (f);",
            "\t\tstk[1] = fstack<T> (f);",
            "\t}",
            "",
            "\tfqueue(){",
            "\t\tfqueue(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tstk[0].push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tif(!stk[1].empty()) stk[1].pop();",
            "\t\telse{",
            "\t\t\twhile(!stk[0].empty()){",
            "\t\t\t\tstk[1].push(stk[0].top());",
            "\t\t\t\tstk[0].pop();",
            "\t\t\t}",
            "",
            "\t\t\tstk[1].pop();",
            "\t\t}",
            "\t}",
            "",
            "\tT query(){",
            "\t\tif(stk[1].empty()) return stk[0].query();",
            "\t\telse if(stk[0].empty()) return stk[1].query();",
            "\t\telse return func(stk[0].query() , stk[1].query());",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn (stk[0].empty() && stk[1].empty());",
            "\t}",
            "};",
            "// Usage :: fqueue<ll> gcdq([&](ll x , ll y){return gcd(x , y);});",
            "/* any function that can be used with seg trees can be used here : min , max , gcd , xor */",
            "",
            ""
        ],
        "description": "generic stack like the min and max stack"
    },
    "grid_dfs": {
        "prefix": "grid_dfs",
        "body": [
            "ll dx[4] = {1 , -1 , 0 , 0};",
            "ll dy[4] = {0 , 0 , 1 , -1};",
            "bool vis[N][N];",
            "void dfs(ll i , ll j){",
            "\tvis[i][j] = 1;",
            "\tfor(ll k=0;k<4;k++){",
            "\t\tll x = i - dx[k];",
            "\t\tll y = j - dy[k];",
            "\t\tif(x >= 0 && y >= 0 && x < n && y < m && vis[x][y] == 0){",
            "\t\t\tdfs(x , y);",
            "\t\t}",
            "\t}",
            "}",
            ""
        ],
        "description": "dfs traversal on grids"
    },
    "isAncestor": {
        "prefix": "isAncestor",
        "body": [
            "ll in[N] , out[N] , timer = 0;",
            "vector<ll> v[N];",
            "bool vis[N];",
            "void dfs(ll node){",
            "\tvis[node]=1;",
            "\tin[node]=timer++;",
            "\tfor(auto child:v[node]){",
            "\t\tif(!vis[child]){",
            "\t\t\tdfs(child);",
            "\t\t}",
            "\t}",
            "\tout[node] = timer++;",
            "}",
            "// check if parent is the ancestor of child or not(1---parent---child)",
            "bool isancestor(ll parent, ll child){",
            "\tif((in[parent] <= in[child]) && (out[parent] >= out[child])) return true;",
            "\telse return false;",
            "}"
        ],
        "description": "finding ancestor in graphs"
    },
    "isDAG": {
        "prefix": "isDAG",
        "body": [
            "vector<ll> v[N];",
            "bool vis[N];",
            "ll tym,dep[N];",
            "void dfs(ll node){",
            "\tvis[node] = 1;",
            "\tfor(auto child : v[node]){",
            "\t\tif(!vis[child]) dfs(child);",
            "\t}",
            "\tdep[node] = tym++;",
            "}",
            "bool isdag(){",
            "\tfor(ll i = 1 ; i <= n ; i++){",
            "\t\tll t1 = dep[i];",
            "\t\tfor(auto child:v[i]){",
            "\t\t\tll t2 = dep[child];",
            "\t\t\tif(t2 > t1) return false;",
            "\t\t}",
            "\t}",
            "\treturn true;",
            "}",
            ""
        ],
        "description": "finding if the graph is directed acyclic or not"
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "long long n , l , in[N] , out[N];",
            "long long timer = 0;",
            "vector<long long> v[N] , up[N];",
            "",
            "void dfs(long long node , long long pr){",
            "\tin[node] = ++timer;",
            "\t",
            "\tup[node][0] = pr;",
            "\tfor(int i = 1 ; i <= l ; i++){",
            "\t\tup[node][i] = up[up[node][i - 1]][i - 1];",
            "\t}",
            "",
            "\tfor(auto child : v[node]){",
            "\t\tif(child != pr){",
            "\t\t\tdfs(child , node);",
            "\t\t}",
            "\t}",
            "",
            "\tout[node] = ++timer;",
            "}",
            "",
            "bool is_ancestor(long long ancestor , long long node){",
            "\treturn (in[ancestor] <= in[node] && out[ancestor] >= out[node]);",
            "}",
            "",
            "long long lca(long long u , long long v){",
            "\tif(is_ancestor(u , v)) return u;",
            "\tif(is_ancestor(v , u)) return v;",
            "",
            "\tfor(int i = l ; i >= 0 ; i--){",
            "\t\tif(!is_ancestor(up[u][i] , v)) u = up[u][i];",
            "\t}",
            "",
            "\treturn up[u][0];",
            "}",
            "",
            "void preprocess(long long root){",
            "\ttimer = 0;",
            "\tl = ceil(log2(n));",
            "",
            "\tfor(int i = 0 ; i < n + 1 ; i++){",
            "\t\tup[i].clear();",
            "\t\tin[i] = out[i] = 0;",
            "\t\tup[i].resize(l + 1);",
            "\t}",
            "",
            "\tdfs(root , root);",
            "}",
            ""
        ],
        "description": "template for lca"
    },
    "isprime": {
        "prefix": "isprime",
        "body": [
            "bool isprime(ll x){",
            "\tfor(ll i = 2 ; i*i <= x ; i++){",
            "\t\tif(x%i == 0) return 0;",
            "\t}",
            "",
            "\treturn 1;",
            "}",
            ""
        ],
        "description": "finding if a number is prime or not "
    },
    "kadane": {
        "prefix": "kadane",
        "body": [
            "ll kadane(vector<ll> v){",
            "\tll n=v.size();",
            "\tll mxsum=0,cursum=0;",
            "\tfor(ll i=0;i<n;i++){",
            "\t\tcursum+=v[i];",
            "\t\tif(cursum<0) cursum=0;",
            "\t\telse mxsum=max(mxsum,cursum);",
            "\t}",
            "\treturn mxsum;",
            "}"
        ],
        "description": "maximum subarray sum"
    },
    "linklist": {
        "prefix": "linklist",
        "body": [
            "struct LinkedList{",
            "\tll data;",
            "\tstruct LinkedList *next;",
            "};",
            "",
            "typedef struct LinkedList *node;",
            "node createNode(ll val){",
            "\tnode newNode;",
            "\tnewNode = (node)calloc(1 , sizeof(struct LinkedList));",
            "\tnewNode -> data = val;",
            "\tnewNode -> next = NULL;",
            "\treturn newNode;",
            "}",
            "// node head = createNode(10);",
            "// node head = NULL;",
            ""
        ],
        "description": "struct for linklist"
    },
    "lowest_comman_ancestor": {
        "prefix": "lowest_comman_ancestor",
        "body": [
            "class lca{",
            "\tpublic:",
            "\tll MAX_D;",
            "\tll dfs_timer;",
            "\tvector<vector<ll>> g;",
            "\tvector<vector<ll>> ancestor;",
            "\tvector<bool> visited;",
            "\tvector<ll> depth;",
            "\tvector<ll> en;",
            "\tvector<ll> ex;",
            "\tvector<ll> par;",
            "\tlca(ll n){",
            "\t\tg.resize(n + 1);",
            "\t\tvisited.resize(n + 1 , 0);",
            "\t\tdepth.resize(n + 1 , 0);",
            "\t\ten.resize(n + 1, 0);",
            "\t\tex.resize(n + 1, 0);",
            "\t\tpar.resize(n + 1, -1);",
            "\t\tdfs_timer = 0;",
            "\t\tMAX_D = ceil(log2(n));",
            "\t\tancestor = vector<vector<ll>>(MAX_D + 1, vector<ll>(n + 1 , -1));",
            "\t}",
            "\tvoid addEdge(ll l, ll r){",
            "\t\tg[l].push_back(r);",
            "\t}",
            "\tvoid do_dfs(ll sr){",
            "\t\tvisited[sr] = true;",
            "\t\tdfs_timer++;",
            "\t\ten[sr] = dfs_timer;",
            "\t\tfor(auto child : g[sr]){",
            "\t\t\tif(!visited[child]){",
            "\t\t\t\tancestor[0][child] = sr;",
            "\t\t\t\tdepth[child] = depth[sr] + 1;",
            "\t\t\t\tpar[child] = sr; ",
            "\t\t\t\tdo_dfs(child);",
            "\t\t\t}",
            "\t\t}",
            "\t\tdfs_timer++;",
            "\t\tex[sr] = dfs_timer;",
            "\t}",
            "\tvoid build_lca_table(){",
            "\t\tll n = (ll) g.size() - 1;",
            "\t\tthis->do_dfs(1);",
            "\t\tfor(ll d = 1; d <= MAX_D; d++){",
            "\t\t\tfor(ll i = 1; i <= n; i++){",
            "\t\t\t\tif(ancestor[d - 1][i] != -1){",
            "\t\t\t\t\tancestor[d][i] = ancestor[d - 1][ancestor[d - 1][i]];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tll climb(ll l , ll d){",
            "\t\tll i = l;",
            "\t\tfor(ll dd = 0; (dd <= MAX_D && i != -1) ;dd++){",
            "\t\t\tif((1 << dd) & d) i = ancestor[dd][i];",
            "\t\t}",
            "\t\treturn i;",
            "\t}",
            "\tll get_lca(ll i , ll j){",
            "\t\tif(depth[i] > depth[j]) i = climb(i , depth[i] - depth[j]);",
            "\t\tif(depth[j] > depth[i]) j = climb(j , depth[j] - depth[i]);",
            "\t\tassert(depth[j] == depth[i]);",
            "\t\tif(i == j) return i;",
            "\t\tfor(ll d = MAX_D; d >= 0; --d){",
            "\t\t\tif(ancestor[d][i] != ancestor[d][j]){",
            "\t\t\t\ti = ancestor[d][i];",
            "\t\t\t\tj = ancestor[d][j];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ancestor[0][i];",
            "\t}",
            "\tll isAncestor(ll u , ll v){",
            "\t\treturn (en[u] <= en[v] && ex[v] <= ex[u]);",
            "\t}",
            "};"
        ],
        "description": "lowest_comman_ancestor"
    },
    "kosaraju": {
        "prefix": "kosaraju",
        "body": [
            "vector<ll> v[N],revv[N],topo;",
            "bool vis1[N],vis2[N];",
            "void dfs1(ll node){",
            "\tvis1[node]=1;",
            "\tfor(auto child:v[node]){",
            "\t\tif(!vis1[child]){",
            "\t\t\tdfs1(child);",
            "\t\t}",
            "\t}",
            "\ttopo.pb(node);",
            "}",
            "void dfs2(ll node){",
            "\tvis2[node]=1;",
            "\tfor(auto child:revv[node]){",
            "\t\tif(!vis2[child]){",
            "\t\t\tdfs2(child);",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "kosaraju algorithm"
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "// gives number of even and odd pallindromes centered at i",
            "vector<vector<long long>>  manacher(string s){",
            "\tll n = (int)s.size();",
            "\tstring t; t.push_back('@');",
            "\tt.push_back('#');",
            "\tfor(int i = 0 ; i < n ; i++) t.push_back(s[i]) , t.push_back('#');",
            "\tt.push_back('?');",
            "",
            "\tn = (int)t.size();",
            "\tvector<long long> P(n + 1 , 0);",
            "\tfor(int i = 0 , c = 0 , r = 0 ; i < n ; i++){",
            "\t\tP[i] = (i > r) ? (0) : (min(P[c + c - i] , r - i));",
            "\t\twhile(t[i - P[i] - 1] == t[i + P[i] + 1]) P[i]++;",
            "",
            "\t\tif(i + P[i] > r) c = i , r = i + P[i];",
            "\t}",
            "",
            "\tvector<vector<long long>> ans;",
            "\tvector<long long> odd , even;",
            "",
            "\tfor(int i = 1 ; i < n - 1 ; ++i){",
            "\t\tif(t[i] == '#') even.push_back(P[i]/2);",
            "\t\telse odd.push_back((P[i] + 1)/2);",
            "\t}",
            "",
            "\tans.push_back(even);",
            "\tans.push_back(odd);",
            "",
            "\treturn ans;",
            "}",
            ""
        ],
        "description": "manacher algorithm"
    },
    "maxtrix_exponentiation": {
        "prefix": "maxtrix_exponentiation",
        "body": [
            "vector<vll> matrixmul(vector<vll> v1 , vector<vll> v2){",
            "\tll n = v1.size();",
            "",
            "\tvector<vll > a;",
            "",
            "\tfor(ll i = 0 ; i <  n ; i++){",
            "\t\tvll x ;",
            "\t\tfor(ll j = 0 ; j < n; j++){",
            "\t\t\tll val = 0;",
            "\t\t\tfor(ll k = 0 ; k < n; k++){",
            "\t\t\t\tval += v1[i][k] * v2[k][j];",
            "\t\t\t\tval %= m;",
            "\t\t\t}",
            "\t\t\tx.pb(val);",
            "\t\t}",
            "\t\ta.pb(x);",
            "\t}   ",
            "",
            "\treturn a; ",
            "}",
            "vector<vll> matrixpow(vector<vll>v , ll ex){",
            "\tif(ex == 1) return v;",
            "\telse{",
            "\t\tvector<vll> temp = matrixpow(v, ex/2);",
            "\t\tvector<vll> mul = matrixmul(temp , temp);",
            "\t\tif(ex&1) return matrixmul(mul , v);",
            "\t\telse return mul;",
            "\t}",
            "}",
            "",
            ""
        ],
        "description": "code for maxtrix exponentiation "
    },
    "maxstack": {
        "prefix": "maxstack",
        "body": [
            "// insert from front, remove from front, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fstack{ // like min stack ",
            "\tstack<T> stk , fstk;",
            "\tF func;",
            "",
            "\tfstack(const F &f): func(f) {};",
            "",
            "\tfstack(){",
            "\t\tfstack(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tif(stk.empty()) fstk.push(add);",
            "\t\telse fstk.push(func(fstk.top() , add));",
            "",
            "\t\tstk.push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tassert(!stk.empty());",
            "\t\tstk.pop();",
            "\t\tfstk.pop();",
            "\t}",
            "",
            "\tT top(){",
            "\t\tassert(!stk.empty());",
            "\t\treturn stk.top();",
            "\t}",
            "",
            "\tT query(){",
            "\t\tassert(!fstk.empty());",
            "\t\treturn fstk.top();",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn stk.empty();",
            "\t}",
            "};",
            "",
            "// insert from front, remove from back, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fqueue{ // like min queue ",
            "\tfstack<T> stk[2];",
            "\tF func;",
            "",
            "\tfqueue(const F &f) : func(f){",
            "\t\tstk[0] = fstack<T> (f);",
            "\t\tstk[1] = fstack<T> (f);",
            "\t}",
            "",
            "\tfqueue(){",
            "\t\tfqueue(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tstk[0].push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tif(!stk[1].empty()) stk[1].pop();",
            "\t\telse{",
            "\t\t\twhile(!stk[0].empty()){",
            "\t\t\t\tstk[1].push(stk[0].top());",
            "\t\t\t\tstk[0].pop();",
            "\t\t\t}",
            "",
            "\t\t\tstk[1].pop();",
            "\t\t}",
            "\t}",
            "",
            "\tT query(){",
            "\t\tif(stk[1].empty()) return stk[0].query();",
            "\t\telse if(stk[0].empty()) return stk[1].query();",
            "\t\telse return func(stk[0].query() , stk[1].query());",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn (stk[0].empty() && stk[1].empty());",
            "\t}",
            "};",
            "// Usage :: fqueue<ll> gcdq([&](ll x , ll y){return gcd(x , y);});",
            "/* any function that can be used with seg trees can be used here : min , max , gcd , xor */",
            ""
        ],
        "description": "maxstack"
    },
    "minstack": {
        "prefix": "minstack",
        "body": [
            "// insert from front, remove from front, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fstack{ // like min stack ",
            "\tstack<T> stk , fstk;",
            "\tF func;",
            "",
            "\tfstack(const F &f): func(f) {};",
            "",
            "\tfstack(){",
            "\t\tfstack(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tif(stk.empty()) fstk.push(add);",
            "\t\telse fstk.push(func(fstk.top() , add));",
            "",
            "\t\tstk.push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tassert(!stk.empty());",
            "\t\tstk.pop();",
            "\t\tfstk.pop();",
            "\t}",
            "",
            "\tT top(){",
            "\t\tassert(!stk.empty());",
            "\t\treturn stk.top();",
            "\t}",
            "",
            "\tT query(){",
            "\t\tassert(!fstk.empty());",
            "\t\treturn fstk.top();",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn stk.empty();",
            "\t}",
            "};",
            "",
            "// insert from front, remove from back, query function for elements present",
            "template<typename T, class F = function<T(const T& , const T&)>>",
            "struct fqueue{ // like min queue ",
            "\tfstack<T> stk[2];",
            "\tF func;",
            "",
            "\tfqueue(const F &f) : func(f){",
            "\t\tstk[0] = fstack<T> (f);",
            "\t\tstk[1] = fstack<T> (f);",
            "\t}",
            "",
            "\tfqueue(){",
            "\t\tfqueue(nullptr);",
            "\t}",
            "",
            "\tvoid push(T add){",
            "\t\tstk[0].push(add);",
            "\t}",
            "",
            "\tvoid pop(){",
            "\t\tif(!stk[1].empty()) stk[1].pop();",
            "\t\telse{",
            "\t\t\twhile(!stk[0].empty()){",
            "\t\t\t\tstk[1].push(stk[0].top());",
            "\t\t\t\tstk[0].pop();",
            "\t\t\t}",
            "",
            "\t\t\tstk[1].pop();",
            "\t\t}",
            "\t}",
            "",
            "\tT query(){",
            "\t\tif(stk[1].empty()) return stk[0].query();",
            "\t\telse if(stk[0].empty()) return stk[1].query();",
            "\t\telse return func(stk[0].query() , stk[1].query());",
            "\t}",
            "",
            "\tbool empty(){",
            "\t\treturn (stk[0].empty() && stk[1].empty());",
            "\t}",
            "};",
            "// Usage :: fqueue<ll> gcdq([&](ll x , ll y){return gcd(x , y);});",
            "/* any function that can be used with seg trees can be used here : min , max , gcd , xor */"
        ],
        "description": "minstack"
    },
    "ncr_table": {
        "prefix": "ncr_table",
        "body": [
            "#define NCR",
            "ll ncr[N][N];",
            "void factorial() {",
            "\t// (n r) = (n-1 r-1) + (n-1 r)",
            "\tFOR(i, 0, N - 1) {",
            "\t\tFOR(j, 0, N - 1) {",
            "\t\t\tif (i == 0 && j == 0) ncr[0][0] = 1;",
            "\t\t\telse if (i == 0) ncr[i][j] = 0;",
            "\t\t\telse if (j == 0) ncr[i][j] = 1;",
            "\t\t\telse ncr[i][j] = ncr[i - 1][j - 1] + ncr[i - 1][j];",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "ncr calculation for small numbers using dp"
    },
    "nearest_smallest_number": {
        "prefix": "nearest_smallest_number",
        "body": [
            "vector<long long> nearest_smallest_on_left(vector<long long> &A) {",
            "\tint n = A.size();",
            "\tstack<pair<long long, long long>> s;",
            "\tvector<long long> index(n, -1);",
            "",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tint x = A[i];",
            "\t\twhile (!s.empty() && s.top().first >= x) s.pop();",
            "\t\tif (s.empty()) index[i] = -1;",
            "\t\telse index[i] = s.top().second;",
            "",
            "\t\ts.push(make_pair(A[i], i));",
            "\t}",
            "",
            "\treturn index;",
            "}",
            "// reverse(A.begin(), A.end());",
            "// vector<int> right = nearest_smallest_on_left(A);",
            "// reverse(right.begin(), right.end());",
            "// for (int i = 0; i < n; i++) if (right[i] != -1) right[i] = n - 1 - right[i];",
            "// reverse(A.begin(), A.end());",
            ""
        ],
        "description": "finding nearest smallest number less than list[i]"
    },
    "ordered_set": {
        "prefix": "ordered_set",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "// above one shoud be above using namespace std",
            "",
            "template<typename T>",
            "#define o_set(T) tree<T, null_type,less<T>, rb_tree_tag,tree_order_statistics_node_update>",
            "// o_set(ll) name ; -- defining ordered set",
            "//member functions :",
            "//1. order_of_key(k) : number of elements strictly lesser than k",
            "//2. find_by_order(k) : counting from zero it returns the k-th largest or smallest element in the set - returns iterator",
            ""
        ],
        "description": "ordered_set"
    },
    "preprocess": {
        "prefix": "preprocess",
        "body": [
            "#define PREPROCESS",
            "void preprocess(){ ",
            "\t${1:}",
            "}",
            ""
        ],
        "description": "preprocess"
    },
    "rational_number": {
        "prefix": "rational_number",
        "body": [
            "struct RationalNumber {",
            "\tint p, q;",
            "\tRationalNumber() {",
            "\t\tp = 0, q = 1;",
            "\t}",
            "\tRationalNumber(int num, int den) {",
            "\t\tassert(den != 0);",
            "\t\tp = num, q = den;",
            "\t\tint g = gcd(p, q);",
            "\t\tp /= g, q /= g;",
            "\t}",
            "",
            "\t// first argument R1 is understood here",
            "\tRationalNumber operator +(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn RationalNumber(q2 * p1 + p2 * q1, q1 * q2);",
            "\t}",
            "\tRationalNumber operator *(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn RationalNumber(p1 * p2 , q1 * q2);",
            "\t}",
            "",
            "\tbool operator >(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn (q2 * p1 > p2 * q1);",
            "\t}",
            "",
            "\tbool operator <(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn (q2 * p1 < p2 * q1);",
            "\t}",
            "",
            "",
            "\tbool operator >=(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn (q2 * p1 >= p2 * q1);",
            "\t}",
            "",
            "\tbool operator <=(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn (q2 * p1 <= p2 * q1);",
            "\t}",
            "",
            "\tbool operator ==(RationalNumber other) {",
            "\t\tint p1 = this->p;",
            "\t\tint q1 = this->q;",
            "",
            "\t\tint p2 = other.p;",
            "\t\tint q2 = other.q;",
            "",
            "\t\treturn (q2 * p1 == p2 * q1);",
            "\t}",
            "",
            "};",
            "",
            "bool operator !=(RationalNumber R1, RationalNumber R2) {// use two arguments",
            "\tint p1 = R1.p;",
            "\tint q1 = R1.q;",
            "",
            "\tint p2 = R2.p;",
            "\tint q2 = R2.q;",
            "",
            "\treturn (q2 * p1 != p2 * q1);",
            "}",
            "ostream& operator <<(ostream& out, RationalNumber R) {",
            "\tout << R.p << \"/\" << R.q ;",
            "\treturn out;",
            "}",
            ""
        ],
        "description": "struct for rational number"
    },
    "sparse_table": {
        "prefix": "sparse_table",
        "body": [
            "template <typename T, class F = function<T(const T&, const T&)>>",
            "class sparsetable {",
            " public:",
            "  int n;",
            "  vector<vector<T>> mat;",
            "  F func;",
            " ",
            "  sparsetable(const vector<T>& a, const F& f) : func(f) {",
            "\tn = static_cast<int>(a.size());",
            "\tint max_log = 32 - __builtin_clz(n);",
            "\tmat.resize(max_log);",
            "\tmat[0] = a;",
            "\tfor (int j = 1; j < max_log; j++) {",
            "\t  mat[j].resize(n - (1 << j) + 1);",
            "\t  for (int i = 0; i <= n - (1 << j); i++) {",
            "\t\tmat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
            "\t  }",
            "\t}",
            "  }",
            " ",
            "  T get(int from, int to) const {",
            "\tassert(0 <= from && from <= to && to <= n - 1);",
            "\tint lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "\treturn func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
            "  }",
            "};",
            "/* ",
            " sparsetable<ll> sp (a , [&] (int i , int j){ return max(i , j); } );",
            " // to get max from l,r",
            " ll x = sp.get(l,r);",
            "*/",
            ""
        ],
        "description": "struct for sparse table"
    },
    "spf": {
        "prefix": "spf",
        "body": [
            "#define SIEVE",
            "// finding shortest prime factor in O(nlog(n))",
            "const ll mX = ${1:N};",
            "ll spf[mX];",
            "void sieve (){",
            "\tspf[1] = 1;",
            "\tfor(ll i = 2 ; i < mX ; i++){",
            "\t\t if(spf[i] == 0){",
            "\t\t\tspf[i] = i;",
            "\t\t\tfor (ll j = 1ll * i * i ; j < mX ; j += i){",
            "\t\t\t\tif(spf[j] == 0) spf[j] = i;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            ""
        ],
        "description": "code for spf"
    },
    "trie_with_map": {
        "prefix": "trie_with_map",
        "body": [
            "const int MX_SZ = 1e5 + 11;",
            "map<int, int> trie[MX_SZ];",
            "int endofWord[MX_SZ], ptr;",
            "void insert(string &key) {",
            "\tint n = (int)key.size(), index = 0;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tif (!trie[index].count(key[i] - 'a')) trie[index][key[i] - 'a'] = ++ptr;",
            "\t\tindex = trie[index][key[i] - 'a'];",
            "\t}",
            "\tendofWord[index]++;",
            "}",
            "void erase(string &key) {",
            "\tint n = (int)key.size(), index = 0;",
            "",
            "}",
            "bool search(string &key) {",
            "\tint n = (int)key.size(), index = 0;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tif (!trie[index].count(key[i] - 'a')) return 0;",
            "\t\tindex = trie[index][key[i] - 'a'];",
            "\t}",
            "\tif (endofWord[index]) return 1;",
            "\treturn 0;",
            "}",
            ""
        ],
        "description": "trie implementaion using map"
    }
}